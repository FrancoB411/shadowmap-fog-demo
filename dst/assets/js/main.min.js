/*! modernizr 3.3.1 (Custom Build) | MIT *
 * https://modernizr.com/download/?-webgl-setclasses !*/
"use strict";

!(function (e, n, t) {
  function o(e, n) {
    return typeof e === n;
  }function s() {
    var e, n, t, s, a, i, f;for (var c in l) if (l.hasOwnProperty(c)) {
      if ((e = [], n = l[c], n.name && (e.push(n.name.toLowerCase()), n.options && n.options.aliases && n.options.aliases.length))) for (t = 0; t < n.options.aliases.length; t++) e.push(n.options.aliases[t].toLowerCase());for (s = o(n.fn, "function") ? n.fn() : n.fn, a = 0; a < e.length; a++) i = e[a], f = i.split("."), 1 === f.length ? Modernizr[f[0]] = s : (!Modernizr[f[0]] || Modernizr[f[0]] instanceof Boolean || (Modernizr[f[0]] = new Boolean(Modernizr[f[0]])), Modernizr[f[0]][f[1]] = s), r.push((s ? "" : "no-") + f.join("-"));
    }
  }function a(e) {
    var n = c.className,
        t = Modernizr._config.classPrefix || "";if ((u && (n = n.baseVal), Modernizr._config.enableJSClass)) {
      var o = new RegExp("(^|\\s)" + t + "no-js(\\s|$)");n = n.replace(o, "$1" + t + "js$2");
    }Modernizr._config.enableClasses && (n += " " + t + e.join(" " + t), u ? c.className.baseVal = n : c.className = n);
  }function i() {
    return "function" != typeof n.createElement ? n.createElement(arguments[0]) : u ? n.createElementNS.call(n, "http://www.w3.org/2000/svg", arguments[0]) : n.createElement.apply(n, arguments);
  }var r = [],
      l = [],
      f = { _version: "3.3.1", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function on(e, n) {
      var t = this;setTimeout(function () {
        n(t[e]);
      }, 0);
    }, addTest: function addTest(e, n, t) {
      l.push({ name: e, fn: n, options: t });
    }, addAsyncTest: function addAsyncTest(e) {
      l.push({ name: null, fn: e });
    } },
      Modernizr = function Modernizr() {};Modernizr.prototype = f, Modernizr = new Modernizr();var c = n.documentElement,
      u = "svg" === c.nodeName.toLowerCase();Modernizr.addTest("webgl", function () {
    var n = i("canvas"),
        t = "probablySupportsContext" in n ? "probablySupportsContext" : "supportsContext";return t in n ? n[t]("webgl") || n[t]("experimental-webgl") : "WebGLRenderingContext" in e;
  }), s(), a(r), delete f.addTest, delete f.addAsyncTest;for (var p = 0; p < Modernizr._q.length; p++) Modernizr._q[p]();e.Modernizr = Modernizr;
})(window, document);
/*!
 * Useragnt
 * v0.3.1
 * 
 * Copyright (c) 2016 Yuichiroh Arai
 * Released under the MIT license
 * http://opensource.org/licenses/mit-license.php
 * 
 * detects: mobile, tablet, pc, windows, mac, linux, ios, android, edge, ie, safari, chrome, firefox, opera
!*/
"use strict";

!(function (e, o) {
  function i(e) {
    return n.indexOf(e) != -1;
  }function r(e) {
    var o = e.split("."),
        i = {};return i.str = e, i.float = parseFloat(e) || 0, i.major = o.length > 0 ? parseInt(o[0]) || 0 : 0, i.minor = o.length > 1 ? parseInt(o[1]) || 0 : 0, i.build = o.length > 2 ? parseInt(o[2]) || 0 : 0, i.revision = o.length > 3 ? parseInt(o[3]) || 0 : 0, i;
  }var a = {};a._detects = ["mobile", "tablet", "pc", "windows", "mac", "linux", "ios", "android", "edge", "ie", "safari", "chrome", "firefox", "opera"];var n = a.userAgent = e.navigator.userAgent.toLowerCase();a.mobile = i("iphone") || i("ipod") || i("android") && i("mobile") || i("windows") && i("phone") || i("firefox") && i("mobile") || i("blackberry"), a.tablet = i("ipad") || i("android") && !i("mobile") || i("windows") && i("touch") && !i("tablet pc") || i("firefox") && i("tablet") || i("kindle") || i("silk") || i("playbook"), a.pc = !i("iphone") && !i("ipod") && !i("ipad") && !i("android") && (!i("windows") || !i("phone") && (!i("touch") || i("tablet pc"))) && (!i("firefox") || !i("mobile") && !i("tablet")) && !i("blackberry") && !i("kindle") && !i("silk") && !i("playbook"), a.windows = i("windows"), a.mac = i("mac os x") && !i("iphone") && !i("ipad") && !i("ipod"), a.linux = i("linux") && !i("android"), a.ios = i("iphone") || i("ipad") || i("ipod"), a.ios && (a.ios = new Boolean(!0), n.match(/ os ([\d_]+)/g), a.ios.version = r(RegExp.$1.replace("_", "."))), a.android = i("android"), a.android && (a.android = new Boolean(!0), n.match(/android ([\d\.]+)/g), a.android.version = r(RegExp.$1)), a.edge = i("edge"), a.ie = i("trident") || i("msie"), a.safari = i("safari") && !i("android") && !i("edge") && !i("opera") && !i("opr") && !i("chrome"), a.chrome = i("chrome") && !i("edge") && !i("opera") && !i("opr"), a.chrome && (a.chrome = new Boolean(!0), n.match(/chrome\/([\d.]+)/g), a.chrome.version = r(RegExp.$1)), a.firefox = i("firefox") && !i("edge"), a.opera = i("opera") || i("opr");var d,
      t,
      s,
      l = a._classPrefix = "",
      p = o.documentElement,
      c = p.className;for (t = a._detects.length, d = 0; d < t; d++) s = a._detects[d], c += a[s] ? " " + l + s : " " + l + "no-" + s;p.className = c, e.Useragnt = a;
})(window, document);
/**
 * @author yomboprime https://github.com/yomboprime
 *
 * GPUComputationRenderer, based on SimulationRenderer by zz85
 *
 * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats
 * for each compute element (texel)
 *
 * Each variable has a fragment shader that defines the computation made to obtain the variable in question.
 * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader
 * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.
 *
 * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used
 * as inputs to render the textures of the next frame.
 *
 * The render targets of the variables can be used as input textures for your visualization shaders.
 *
 * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.
 * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...
 *
 * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:
 * #DEFINE resolution vec2( 1024.0, 1024.0 )
 *
 * -------------
 *
 * Basic use:
 *
 * // Initialization...
 *
 * // Create computation renderer
 * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );
 *
 * // Create initial state float textures
 * var pos0 = gpuCompute.createTexture();
 * var vel0 = gpuCompute.createTexture();
 * // and fill in here the texture data...
 *
 * // Add texture variables
 * var velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, pos0 );
 * var posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, vel0 );
 *
 * // Add variable dependencies
 * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );
 * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );
 *
 * // Add custom uniforms
 * velVar.material.uniforms.time = { value: 0.0 };
 *
 * // Check for completeness
 * var error = gpuCompute.init();
 * if ( error !== null ) {
 *		console.error( error );
  * }
 *
 *
 * // In each frame...
 *
 * // Compute!
 * gpuCompute.compute();
 *
 * // Update texture uniforms in your visualization materials with the gpu renderer output
 * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;
 *
 * // Do your rendering
 * renderer.render( myScene, myCamera );
 *
 * -------------
 *
 * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)
 * Note that the shaders can have multiple input textures.
 *
 * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );
 * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );
 *
 * var inputTexture = gpuCompute.createTexture();
 *
 * // Fill in here inputTexture...
 *
 * myFilter1.uniforms.theTexture.value = inputTexture;
 *
 * var myRenderTarget = gpuCompute.createRenderTarget();
 * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;
 *
 * var outputRenderTarget = gpuCompute.createRenderTarget();
 *
 * // Now use the output texture where you want:
 * myMaterial.uniforms.map.value = outputRenderTarget.texture;
 *
 * // And compute each frame, before rendering to screen:
 * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );
 * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );
 * 
 *
 *
 * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.
 * @param {WebGLRenderer} renderer The renderer
  */

"use strict";

function GPUComputationRenderer(sizeX, sizeY, renderer) {

	this.variables = [];

	this.currentTextureIndex = 0;

	var scene = new THREE.Scene();

	var camera = new THREE.Camera();
	camera.position.z = 1;

	var passThruUniforms = {
		texture: { value: null }
	};

	var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);

	var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), passThruShader);
	scene.add(mesh);

	this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {

		var material = this.createShaderMaterial(computeFragmentShader);

		var variable = {
			name: variableName,
			initialValueTexture: initialValueTexture,
			material: material,
			dependencies: null,
			renderTargets: [],
			wrapS: null,
			wrapT: null,
			minFilter: THREE.NearestFilter,
			magFilter: THREE.NearestFilter
		};

		this.variables.push(variable);

		return variable;
	};

	this.setVariableDependencies = function (variable, dependencies) {

		variable.dependencies = dependencies;
	};

	this.init = function () {

		if (!renderer.extensions.get("OES_texture_float")) {

			return "No OES_texture_float support for float textures.";
		}

		if (renderer.capabilities.maxVertexTextures === 0) {

			return "No support for vertex shader textures.";
		}

		for (var i = 0; i < this.variables.length; i++) {

			var variable = this.variables[i];

			// Creates rendertargets and initialize them with input texture
			variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
			variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
			this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
			this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);

			// Adds dependencies uniforms to the ShaderMaterial
			var material = variable.material;
			var uniforms = material.uniforms;
			if (variable.dependencies !== null) {

				for (var d = 0; d < variable.dependencies.length; d++) {

					var depVar = variable.dependencies[d];

					if (depVar.name !== variable.name) {

						// Checks if variable exists
						var found = false;
						for (var j = 0; j < this.variables.length; j++) {

							if (depVar.name === this.variables[j].name) {
								found = true;
								break;
							}
						}
						if (!found) {
							return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
						}
					}

					uniforms[depVar.name] = { value: null };

					material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;
				}
			}
		}

		this.currentTextureIndex = 0;

		return null;
	};

	this.compute = function () {

		var currentTextureIndex = this.currentTextureIndex;
		var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;

		for (var i = 0, il = this.variables.length; i < il; i++) {

			var variable = this.variables[i];

			// Sets texture dependencies uniforms
			if (variable.dependencies !== null) {

				var uniforms = variable.material.uniforms;
				for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {

					var depVar = variable.dependencies[d];
					// console.log(depVar);

					uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
				}
			}

			// Performs the computation for this variable
			this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
		}

		this.currentTextureIndex = nextTextureIndex;
	};

	this.getCurrentRenderTarget = function (variable) {

		return variable.renderTargets[this.currentTextureIndex];
	};

	this.getAlternateRenderTarget = function (variable) {

		return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
	};

	function addResolutionDefine(materialShader) {

		materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + " )";
	};
	this.addResolutionDefine = addResolutionDefine;

	// The following functions can be used to compute things manually

	function createShaderMaterial(computeFragmentShader, uniforms) {

		uniforms = uniforms || {};

		var material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: getPassThroughVertexShader(),
			fragmentShader: computeFragmentShader
		});

		addResolutionDefine(material);

		return material;
	};
	this.createShaderMaterial = createShaderMaterial;

	this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {

		sizeXTexture = sizeXTexture || sizeX;
		sizeYTexture = sizeYTexture || sizeY;

		wrapS = wrapS || THREE.ClampToEdgeWrapping;
		wrapT = wrapT || THREE.ClampToEdgeWrapping;

		minFilter = minFilter || THREE.NearestFilter;
		magFilter = magFilter || THREE.NearestFilter;

		var floatType = Useragnt.ios ? THREE.HalfFloatType : THREE.FloatType;

		var renderTarget = new THREE.WebGLRenderTarget(sizeXTexture, sizeYTexture, {
			wrapS: wrapS,
			wrapT: wrapT,
			minFilter: minFilter,
			magFilter: magFilter,
			format: THREE.RGBAFormat,
			type: floatType,
			stencilBuffer: false
		});

		return renderTarget;
	};

	this.createTexture = function (sizeXTexture, sizeYTexture) {

		sizeXTexture = sizeXTexture || sizeX;
		sizeYTexture = sizeYTexture || sizeY;

		var floatType = Useragnt.ios ? THREE.HalfFloatType : THREE.FloatType;

		var a = new Float32Array(sizeXTexture * sizeYTexture * 4);
		var texture = new THREE.DataTexture(a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType);
		texture.needsUpdate = true;

		return texture;
	};

	this.renderTexture = function (input, output) {

		// Takes a texture, and render out in rendertarget
		// input = Texture
		// output = RenderTarget

		passThruUniforms.texture.value = input;

		this.doRenderTarget(passThruShader, output);

		passThruUniforms.texture.value = null;
	};

	this.doRenderTarget = function (material, output) {

		mesh.material = material;
		renderer.render(scene, camera, output);
		mesh.material = passThruShader;
	};

	// Shaders

	function getPassThroughVertexShader() {

		return "void main()	{\n" + "\n" + "	gl_Position = vec4( position, 1.0 );\n" + "\n" + "}\n";
	}

	function getPassThroughFragmentShader() {

		return "uniform sampler2D texture;\n" + "\n" + "void main() {\n" + "\n" + "	vec2 uv = gl_FragCoord.xy / resolution.xy;\n" + "\n" + "	gl_FragColor = texture2D( texture, uv );\n" + "\n" + "}\n";
	}
}
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

'use strict';

THREE.OrbitControls = function (object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;
	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;
	};

	this.reset = function () {

		scope.target.copy(scope.target0);
		scope.object.position.copy(scope.position0);
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent(changeEvent);

		scope.update();

		state = STATE.NONE;
	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = (function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy(position).sub(scope.target);

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat);

			// angle from z-axis around y-axis
			spherical.setFromVector3(offset);

			if (scope.autoRotate && state === STATE.NONE) {

				rotateLeft(getAutoRotationAngle());
			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

			// restrict phi to be between desired limits
			spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

			spherical.makeSafe();

			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

			// move target to panned location
			scope.target.add(panOffset);

			offset.setFromSpherical(spherical);

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse);

			position.copy(scope.target).add(offset);

			scope.object.lookAt(scope.target);

			if (scope.enableDamping === true) {

				sphericalDelta.theta *= 1 - scope.dampingFactor;
				sphericalDelta.phi *= 1 - scope.dampingFactor;
			} else {

				sphericalDelta.set(0, 0, 0);
			}

			scale = 1;
			panOffset.set(0, 0, 0);

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

				scope.dispatchEvent(changeEvent);

				lastPosition.copy(scope.object.position);
				lastQuaternion.copy(scope.object.quaternion);
				zoomChanged = false;

				return true;
			}

			return false;
		};
	})();

	this.dispose = function () {

		scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
		scope.domElement.removeEventListener('mousedown', onMouseDown, false);
		scope.domElement.removeEventListener('wheel', onMouseWheel, false);

		scope.domElement.removeEventListener('touchstart', onTouchStart, false);
		scope.domElement.removeEventListener('touchend', onTouchEnd, false);
		scope.domElement.removeEventListener('touchmove', onTouchMove, false);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		window.removeEventListener('keydown', onKeyDown, false);

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function rotateLeft(angle) {

		sphericalDelta.theta -= angle;
	}

	function rotateUp(angle) {

		sphericalDelta.phi -= angle;
	}

	var panLeft = (function () {

		var v = new THREE.Vector3();

		return function panLeft(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
			v.multiplyScalar(-distance);

			panOffset.add(v);
		};
	})();

	var panUp = (function () {

		var v = new THREE.Vector3();

		return function panUp(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
			v.multiplyScalar(distance);

			panOffset.add(v);
		};
	})();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = (function () {

		var offset = new THREE.Vector3();

		return function pan(deltaX, deltaY) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if (scope.object instanceof THREE.PerspectiveCamera) {

				// perspective
				var position = scope.object.position;
				offset.copy(position).sub(scope.target);
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
				panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
			} else if (scope.object instanceof THREE.OrthographicCamera) {

				// orthographic
				panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
				panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
			} else {

				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
				scope.enablePan = false;
			}
		};
	})();

	function dollyIn(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale /= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	function dollyOut(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale *= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate(event) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownDolly(event) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownPan(event) {

		//console.log( 'handleMouseDownPan' );

		panStart.set(event.clientX, event.clientY);
	}

	function handleMouseMoveRotate(event) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set(event.clientX, event.clientY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleMouseMoveDolly(event) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set(event.clientX, event.clientY);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyIn(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyOut(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleMouseMovePan(event) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set(event.clientX, event.clientY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleMouseUp(event) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel(event) {

		// console.log( 'handleMouseWheel' );

		if (event.deltaY < 0) {

			dollyOut(getZoomScale());
		} else if (event.deltaY > 0) {

			dollyIn(getZoomScale());
		}

		scope.update();
	}

	function handleKeyDown(event) {

		//console.log( 'handleKeyDown' );

		switch (event.keyCode) {

			case scope.keys.UP:
				pan(0, scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan(0, -scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.LEFT:
				pan(scope.keyPanSpeed, 0);
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan(-scope.keyPanSpeed, 0);
				scope.update();
				break;

		}
	}

	function handleTouchStartRotate(event) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchStartDolly(event) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyStart.set(0, distance);
	}

	function handleTouchStartPan(event) {

		//console.log( 'handleTouchStartPan' );

		panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchMoveRotate(event) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleTouchMoveDolly(event) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyEnd.set(0, distance);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyOut(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyIn(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleTouchMovePan(event) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleTouchEnd(event) {}

	//console.log( 'handleTouchEnd' );

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {

			if (scope.enableRotate === false) return;

			handleMouseDownRotate(event);

			state = STATE.ROTATE;
		} else if (event.button === scope.mouseButtons.ZOOM) {

			if (scope.enableZoom === false) return;

			handleMouseDownDolly(event);

			state = STATE.DOLLY;
		} else if (event.button === scope.mouseButtons.PAN) {

			if (scope.enablePan === false) return;

			handleMouseDownPan(event);

			state = STATE.PAN;
		}

		if (state !== STATE.NONE) {

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (state === STATE.ROTATE) {

			if (scope.enableRotate === false) return;

			handleMouseMoveRotate(event);
		} else if (state === STATE.DOLLY) {

			if (scope.enableZoom === false) return;

			handleMouseMoveDolly(event);
		} else if (state === STATE.PAN) {

			if (scope.enablePan === false) return;

			handleMouseMovePan(event);
		}
	}

	function onMouseUp(event) {

		if (scope.enabled === false) return;

		handleMouseUp(event);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

		event.preventDefault();
		event.stopPropagation();

		handleMouseWheel(event);

		scope.dispatchEvent(startEvent); // not sure why these are here...
		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

		handleKeyDown(event);
	}

	function onTouchStart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;

				handleTouchStartRotate(event);

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;

				handleTouchStartDolly(event);

				state = STATE.TOUCH_DOLLY;

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;

				handleTouchStartPan(event);

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) {

			scope.dispatchEvent(startEvent);
		}
	}

	function onTouchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;
				if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

				handleTouchMoveRotate(event);

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;
				if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

				handleTouchMoveDolly(event);

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;
				if (state !== STATE.TOUCH_PAN) return; // is this needed?...

				handleTouchMovePan(event);

				break;

			default:

				state = STATE.NONE;

		}
	}

	function onTouchEnd(event) {

		if (scope.enabled === false) return;

		handleTouchEnd(event);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onContextMenu(event) {

		event.preventDefault();
	}

	//

	scope.domElement.addEventListener('contextmenu', onContextMenu, false);

	scope.domElement.addEventListener('mousedown', onMouseDown, false);
	scope.domElement.addEventListener('wheel', onMouseWheel, false);

	scope.domElement.addEventListener('touchstart', onTouchStart, false);
	scope.domElement.addEventListener('touchend', onTouchEnd, false);
	scope.domElement.addEventListener('touchmove', onTouchMove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start

	this.update();
};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

Object.defineProperties(THREE.OrbitControls.prototype, {

	center: {

		get: function get() {

			console.warn('THREE.OrbitControls: .center has been renamed to .target');
			return this.target;
		}

	},

	// backward compatibility

	noZoom: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			return !this.enableZoom;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			this.enableZoom = !value;
		}

	},

	noRotate: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			return !this.enableRotate;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			this.enableRotate = !value;
		}

	},

	noPan: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			return !this.enablePan;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			this.enablePan = !value;
		}

	},

	noKeys: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			return !this.enableKeys;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			this.enableKeys = !value;
		}

	},

	staticMoving: {

		get: function get() {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			return !this.enableDamping;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			this.enableDamping = !value;
		}

	},

	dynamicDampingFactor: {

		get: function get() {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			return this.dampingFactor;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			this.dampingFactor = value;
		}

	}

});
/**
 * @author arya-s / https://github.com/arya-s
 *
 * This is a helper for visualising a given light's shadow map.
 * It works for shadow casting lights: THREE.DirectionalLight and THREE.SpotLight.
 * It renders out the shadow map and displays it on a HUD.
 *
 * Example usage:
 *  1) Include <script src='examples/js/utils/ShadowMapViewer.js'><script> in your html file
 *
 *  2) Create a shadow casting light and name it optionally:
 *    var light = new THREE.DirectionalLight( 0xffffff, 1 );
 *    light.castShadow = true;
 *    light.name = 'Sun';
 *
 *  3) Create a shadow map viewer for that light and set its size and position optionally:
 *    var shadowMapViewer = new THREE.ShadowMapViewer( light );
 *    shadowMapViewer.size.set( 128, 128 ); //width, height  default: 256, 256
 *    shadowMapViewer.position.set( 10, 10 ); //x, y in pixel  default: 0, 0 (top left corner)
 *
 *  4) Render the shadow map viewer in your render loop:
 *    shadowMapViewer.render( renderer );
 *
 *  5) Optionally: Update the shadow map viewer on window resize:
 *    shadowMapViewer.updateForWindowResize();
 *
 *  6) If you set the position or size members directly, you need to call shadowMapViewer.update();
 */

'use strict';

THREE.ShadowMapViewer = function (light) {

  //- Internals
  var scope = this;
  var doRenderLabel = light.name !== undefined && light.name !== '';
  var userAutoClearSetting;

  //Holds the initial position and dimension of the HUD
  var frame = {
    x: 10,
    y: 10,
    width: 256,
    height: 256
  };

  var camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
  camera.position.set(0, 0, 2);
  var scene = new THREE.Scene();

  //HUD for shadow map
  var shader = THREE.UnpackDepthRGBAShader;

  var uniforms = new THREE.UniformsUtils.clone(shader.uniforms);
  var material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  var plane = new THREE.PlaneBufferGeometry(frame.width, frame.height);
  var mesh = new THREE.Mesh(plane, material);

  scene.add(mesh);

  //Label for light's name
  var labelCanvas, labelMesh;

  if (doRenderLabel) {

    labelCanvas = document.createElement('canvas');

    var context = labelCanvas.getContext('2d');
    context.font = 'Bold 20px Arial';

    var labelWidth = context.measureText(light.name).width;
    labelCanvas.width = labelWidth;
    labelCanvas.height = 25; //25 to account for g, p, etc.

    context.font = 'Bold 20px Arial';
    context.fillStyle = 'rgba( 255, 0, 0, 1 )';
    context.fillText(light.name, 0, 20);

    var labelTexture = new THREE.Texture(labelCanvas);
    labelTexture.magFilter = THREE.LinearFilter;
    labelTexture.minFilter = THREE.LinearFilter;
    labelTexture.needsUpdate = true;

    var labelMaterial = new THREE.MeshBasicMaterial({ map: labelTexture, side: THREE.DoubleSide });
    labelMaterial.transparent = true;

    var labelPlane = new THREE.PlaneBufferGeometry(labelCanvas.width, labelCanvas.height);
    labelMesh = new THREE.Mesh(labelPlane, labelMaterial);

    scene.add(labelMesh);
  }

  function resetPosition() {

    scope.position.set(scope.position.x, scope.position.y);
  }

  //- API
  // Set to false to disable displaying this shadow map
  this.enabled = true;

  // Set the size of the displayed shadow map on the HUD
  this.size = {
    width: frame.width,
    height: frame.height,
    set: function set(width, height) {

      this.width = width;
      this.height = height;

      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);

      //Reset the position as it is off when we scale stuff
      resetPosition();
    }
  };

  // Set the position of the displayed shadow map on the HUD
  this.position = {
    x: frame.x,
    y: frame.y,
    set: function set(x, y) {

      this.x = x;
      this.y = y;

      var width = scope.size.width;
      var height = scope.size.height;

      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);

      if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);
    }
  };

  this.render = function (renderer) {

    if (this.enabled) {

      //Because a light's .shadowMap is only initialised after the first render pass
      //we have to make sure the correct map is sent into the shader, otherwise we
      //always end up with the scene's first added shadow casting light's shadowMap
      //in the shader
      //See: https://github.com/mrdoob/three.js/issues/5932
      uniforms.tDiffuse.value = light.shadow.map.texture;

      userAutoClearSetting = renderer.autoClear;
      renderer.autoClear = false; // To allow render overlay
      renderer.clearDepth();
      renderer.render(scene, camera);
      renderer.autoClear = userAutoClearSetting; //Restore user's setting
    }
  };

  this.updateForWindowResize = function () {

    if (this.enabled) {

      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix();

      this.update();
    }
  };

  this.update = function () {

    this.position.set(this.position.x, this.position.y);
    this.size.set(this.size.width, this.size.height);
  };

  //Force an update to set position/size
  this.update();
};

THREE.ShadowMapViewer.prototype.constructor = THREE.ShadowMapViewer;
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

"use strict";

THREE.UnpackDepthRGBAShader = {

  uniforms: {

    "tDiffuse": { value: null },
    "opacity": { value: 1.0 }

  },

  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );", "}"].join("\n")

};
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Controls = (function () {
  function Controls(webgl) {
    _classCallCheck(this, Controls);

    this.webgl = webgl;

    this.props = {
      bgColor: 0xfaf10f, // 0x0d1b4c / 0xd5fffb / 0xfaf10f / 0xff2e63
      // hemisphereLight: true,
      shadowmap: true,
      fog: true
    };
  }

  _createClass(Controls, [{
    key: 'init',
    value: function init() {
      this.objs = this.webgl.objs;

      this.gui = new dat.GUI({ width: 300 });

      // this.gui.add(this.props, 'hemisphereLight').onChange(this.switchHemisphereLight.bind(this));
      this.gui.add(this.props, 'shadowmap').onChange(this.switchShadowmap.bind(this));
      this.gui.add(this.props, 'fog').onChange(this.switchFog.bind(this));

      this.gui.addColor(this.props, 'bgColor').name('bg color').onChange(this.changeBgColor.bind(this));
    }

    // switchHemisphereLight(value){
    //   this.objs.uniforms.isHemiLight.value = value;
    // }

  }, {
    key: 'switchShadowmap',
    value: function switchShadowmap(value) {
      this.objs.uniforms.isShadowmap.value = value;
    }
  }, {
    key: 'switchFog',
    value: function switchFog(value) {
      this.objs.uniforms.isFog.value = value;
    }
  }, {
    key: 'changeBgColor',
    value: function changeBgColor(value) {
      var color = new THREE.Color(value);
      this.webgl.renderer.setClearColor(color, 1.0);
      this.objs.uniforms.uFogColor.value = color;
    }
  }]);

  return Controls;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Loading = (function () {
  function Loading(webgl) {
    _classCallCheck(this, Loading);

    this.webgl = webgl;
    // this.opening = this.webgl.opening;

    // this.isIE11 = (Useragnt.userAgent.indexOf('trident') != -1) ? true : false; //useragntで調べる
    // console.log(this.isIE11, "ie11");

    this.images = [];

    this.texts = [];

    this.audios = [];

    this.jsons = [];

    this.vertShader = [
    /* 00 */"assets/glsl/output.vert"];

    this.fragShader = [
    /* 00 */"assets/glsl/output.frag",
    /* 01 */"assets/glsl/output_shadow.frag",
    /* 02 */"assets/glsl/simulation_def.frag",
    /* 03 */"assets/glsl/simulation_vel.frag",
    /* 04 */"assets/glsl/simulation_pos.frag"];

    this.videos = [];

    this.loadingCount = 0;
    this.wholeLoadingNum = this.texts.length + this.audios.length + this.images.length + this.vertShader.length + this.fragShader.length + this.videos.length + this.jsons.length;

    if (this.images.length > 0) {
      this.initImage();
    }

    if (this.audios.length > 0) {
      this.initAudio();
    }

    if (this.vertShader.length > 0) {
      this.initShader();
    }

    if (this.videos.length > 0) {
      this.initVideo();
    }

    if (this.jsons.length > 0) {
      this.initJson();
    }

    if (this.texts.length > 0) {
      this.initTextTexture();
    }
  }

  _createClass(Loading, [{
    key: "initTextTexture",
    value: function initTextTexture() {
      this.textsLength = this.texts.length;
      this.textsCount = 0;
      this.isTextComplete = false;

      for (var i = 0; i < this.textsLength; i++) {
        this.createTextTexture(i);
      }
    }
  }, {
    key: "createTextTexture",
    value: function createTextTexture(i) {
      var _texture = new THREE.TextureLoader().load(this.texts[i].src, (function (texture) {
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        // console.log("loading img", texture);

        texture.needsUpdate = true;
        this.textsCount++;
        this.loadingCount++;

        var ratio = 0.5;

        this.texts[i] = {
          texture: _texture,
          width: _texture.image.width * ratio,
          height: _texture.image.height * ratio,
          top: this.texts[i].top * ratio,
          isMask: this.texts[i].mask
        };

        if (this.textsCount === this.textsLength) {
          this.isTextComplete = true;
          console.log("comp img");

          this.completeLoadingAll();
        }
      }).bind(this));
    }
  }, {
    key: "initJson",
    value: function initJson() {
      this.jsonsLength = this.jsons.length;
      // this.jsonsCount = 0;
      this.isJsonComplete = false;

      for (var i = 0; i < this.jsonsLength; i++) {
        this.importJson(i);
      }
    }
  }, {
    key: "importJson",
    value: function importJson(i) {

      var _this = this;

      $.ajax({
        type: 'GET',
        url: this.jsons[i],
        dataType: 'json',
        cache: false,
        success: function success(data) {
          var data = data;

          _this.jsons[i] = data;

          _this.loadingCount++;

          // _this.isImageComplete = true;
          // console.log("comp img");

          _this.completeLoadingAll();
        }
      });
    }
  }, {
    key: "initImage",
    value: function initImage() {

      this.imagesLength = this.images.length;
      this.imagesCount = 0;
      this.isImageComplete = false;

      for (var i = 0; i < this.imagesLength; i++) {
        this.createTexture(i);
      }
    }
  }, {
    key: "createTexture",
    value: function createTexture(i) {

      var _texture = new THREE.TextureLoader().load(this.images[i], (function (texture) {
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        // console.log("loading img", texture);

        texture.needsUpdate = true;
        this.imagesCount++;
        this.loadingCount++;

        var ratio = 0.8;

        this.images[i] = _texture;
        // console.log("img");

        if (this.imagesCount === this.imagesLength) {
          this.isImageComplete = true;
          console.log("comp img");

          this.completeLoadingAll();
        }
      }).bind(this));
    }
  }, {
    key: "initAudio",
    value: function initAudio() {
      this.audiosLength = this.audios.length;
      this.audiosCount = 0;

      for (var i = 0; i < this.audios.length; i++) {
        this.audios[i] = this.importAudio(i);
      }
    }
  }, {
    key: "importAudio",
    value: function importAudio(i) {
      var request = new XMLHttpRequest();

      request.open('GET', this.audios[i], true);
      request.responseType = 'arraybuffer';

      var _this = this;

      request.onload = function () {
        // _this.audioContext.decodeAudioData(request.response, function(buffer){
        _this.audios[i] = request.response;
        _this.audiosCount++;
        _this.loadingCount++;
        if (_this.audiosLength === _this.audiosCount) {
          _this.isAudioComplete = true;
          console.log("comp audio");

          _this.completeLoadingAll();
        }
        // });
      };

      request.send();
    }
  }, {
    key: "initShader",
    value: function initShader() {

      this.shaderLength = this.vertShader.length + this.fragShader.length;
      this.shaderCount = 0;

      this.isShaderComplete = false;

      for (var i = 0; i < this.vertShader.length; i++) {
        this.importShader_vert(i);
      }

      for (var i = 0; i < this.fragShader.length; i++) {
        this.importShader_frag(i);
      }
    }
  }, {
    key: "initVideo",
    value: function initVideo() {

      // for ie11, use canvas instead of video
      this.canvases = [];

      this.masks = [];

      this.videoLength = this.videos.length;
      this.videoCount = 0;
      this.isVideoComplete = false;

      for (var i = 0; i < this.videoLength; i++) {
        var video = this.createVideo(this.videos[i], i);
        this.videos[i] = video; // video url -> video element

        this.videos[i + this.videoLength] = video; // video url -> video element

        video.isFirstCanplaythrough = false;
        video.oncanplaythrough = (function (_i, _video) {
          if (_video.isFirstCanplaythrough) return;
          _video.isFirstCanplaythrough = true;
          _video.width = _video.videoWidth;
          _video.height = _video.videoHeight;

          // if(Useragnt.ios) _video.tween = this.maskTween(_video);

          // if(this.isIE11){
          //  var _canvas = this.createCanvas(_video);
          //  this.masks[_i] = this.setCanvasTexture(_canvas);
          // } else {
          this.masks[_i] = this.setVideoTexture(_video);
          // }

          this.videoCount++;
          this.loadingCount++;
          if (this.videoCount === this.videoLength) {
            this.isVideoComplete = true;
            console.log("comp video");

            this.completeLoadingAll();
          }
        }).bind(this, i, video);
      }
    }
  }, {
    key: "createVideo",
    value: function createVideo(src, i) {
      var video = document.createElement("video");
      video.setAttribute("playsinline", "");
      video.setAttribute("muted", "");

      // video.preload = "auto";
      video.autoplay = false;
      video.loop = false;
      video.src = src;
      // video.playsinline = true;
      video.load();
      video.num = i; //
      video.isPlaying = false;
      // console.log(video);
      // videoWrapper.appendChild(video)

      video.onended = (function (i) {
        console.log("videoEnd", video.isPlaying, video.currentTime);
        if (!video.isPlaying) return;

        video.currentTime = 0;

        video.isPlaying = false;
        // video.isEnd.value = 1;

        if (Useragnt.ie) {
          video.pause();
        }

        console.log(Useragnt);
        if (!Useragnt.safari || Useragnt.ios) {
          this.webgl.endVideo();
        }
      }).bind(this, i);

      video.onpause = (function () {
        console.log("pause");
        // if(!video.isPlaying) return;

        if (Useragnt.safari && !Useragnt.ios) {
          if (video.currentTime === video.duration) {
            video.isPlaying = false;
            video.currentTime = 0;

            this.webgl.endVideo();
            video.pause();
          }
        }

        if (video.isPlaying && video.currentTime !== video.duration) {
          video.play();
        }
      }).bind(this);

      video.onplaying = function () {
        console.log("playing");
      };

      video.onplay = (function () {
        console.log("videoPlay", video.isPlaying);

        if (Useragnt.firefox) video.currentTime = 0;

        video.isPlaying = true;
      }).bind(this);

      return video;
    }
  }, {
    key: "createCanvas",
    value: function createCanvas(_video) {
      var canvas = document.createElement("canvas");
      canvas.width = _video.width;
      canvas.height = _video.height;
      var context = canvas.getContext("2d");

      var c = {
        canvas: canvas,
        context: context,
        video: _video
      };

      this.canvases.push(c);

      return c;
    }
  }, {
    key: "setCanvasTexture",
    value: function setCanvasTexture(_mat) {
      var canvas = _mat.canvas;
      var texture = new THREE.Texture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      _mat.texture = texture;

      return texture;
    }
  }, {
    key: "setVideoTexture",
    value: function setVideoTexture(_mat) {
      var texture = new THREE.VideoTexture(_mat);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;

      return texture;
    }
  }, {
    key: "rendering_canvas",
    value: function rendering_canvas() {
      if (!this.isIE11) return;

      for (var i = 0, len = this.canvases.length; i < len; i++) {
        var ctx = this.canvases[i].context;
        var can = this.canvases[i].canvas;
        var video = this.canvases[i].video;
        var tex = this.canvases[i].texture;
        if (video.isPlaying) {
          tex.needsUpdate = true;
          // ctx.clearRect(0, 0, can.width, can.height);
          ctx.drawImage(video, 0, 0);
        } else {
          ctx.clearRect(0, 0, can.width, can.height);
        }
      }
    }
  }, {
    key: "importShader_vert",
    value: function importShader_vert(i) {

      var myRequest = new XMLHttpRequest();

      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.vertShader[i] = myRequest.response;
          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.vertShader[i], true);
      myRequest.send();
    }
  }, {
    key: "importShader_frag",
    value: function importShader_frag(i) {

      var myRequest = new XMLHttpRequest();

      var _this = this;
      myRequest.onreadystatechange = function () {
        if (myRequest.readyState === 4) {
          _this.fragShader[i] = myRequest.response;

          _this.completeShaderLoad();
        }
      };

      myRequest.open("GET", this.fragShader[i], true);
      myRequest.send();
    }
  }, {
    key: "completeShaderLoad",
    value: function completeShaderLoad() {
      this.shaderCount++;
      this.loadingCount++;

      if (this.shaderCount === this.shaderLength) {
        this.isShaderComplete = true;
        console.log("comp shader");
        this.completeLoadingAll();
      }
    }
  }, {
    key: "completeLoadingAll",
    value: function completeLoadingAll() {
      console.log(this.loadingCount, this.wholeLoadingNum);
      // this.webgl.textDom.updateLoadingBar(this.loadingCount / this.wholeLoadingNum);
      if (this.loadingCount !== this.wholeLoadingNum) return;

      console.log("loading --- comp");

      this.webgl.vertShader = this.vertShader;
      this.webgl.fragShader = this.fragShader;
      this.webgl.videos = this.videos;
      this.webgl.canvases = this.canvases;
      this.webgl.masks = this.masks;
      this.webgl.images = this.images;
      this.webgl.audios = this.audios;
      this.webgl.jsons = this.jsons;
      this.webgl.texts = this.texts;

      this.webgl.loadComp();
    }
  }]);

  return Loading;
})();
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Objs = (function () {
  function Objs(webgl) {
    _classCallCheck(this, Objs);

    this.webgl = webgl;
    this.controls = this.webgl.controls;

    this.objSize = 25;
    this.textureSize = 64;

    this.objNum = this.textureSize * this.textureSize;

    this.range = 180;

    this.setLight();

    this.colorPallete = [0x15b7b9, 0xebfffa, 0xc6fce5, 0x00fff0];

    this.sim = new Simulation(this.webgl, this.textureSize);

    this.init();
  }

  _createClass(Objs, [{
    key: 'init',
    value: function init() {
      console.log('init --- objs');

      this.originalG = new THREE.CylinderBufferGeometry(this.objSize * 1.5, this.objSize * 1.5, this.objSize * 0.2, 32);
      // new THREE.CylinderBufferGeometry( this.objSize * 1.2, this.objSize * 1.2, this.objSize * 0.2, 3 );
      // new THREE.BoxBufferGeometry(this.objSize * 2.0, this.objSize * 2.0, this.objSize * 0.2);
      this.instanceG = new THREE.InstancedBufferGeometry();

      // 頂点
      var vertices = this.originalG.attributes.position.clone();
      this.instanceG.addAttribute('position', vertices);

      var normals = this.originalG.attributes.normal.clone();
      this.instanceG.addAttribute("normal", normals);

      // uv
      var uvs = this.originalG.attributes.uv.clone();
      this.instanceG.addAttribute('uv', uvs);

      // index
      if (this.originalG.index) {
        var indices = this.originalG.index.clone();
        this.instanceG.setIndex(indices);
      }

      var nums = new THREE.InstancedBufferAttribute(new Float32Array(this.objNum * 1), 1, 1);
      var randoms = new THREE.InstancedBufferAttribute(new Float32Array(this.objNum * 1), 1, 1);
      var colors = new THREE.InstancedBufferAttribute(new Float32Array(this.objNum * 3), 3, 1);

      for (var i = 0; i < this.objNum; i++) {
        nums.setX(i, i);

        randoms.setX(i, Math.random());

        var hex = this.colorPallete[Math.floor(this.colorPallete.length * Math.random())];

        var color = new THREE.Color(hex);
        colors.setXYZ(i, color.r, color.g, color.b);
      }

      this.instanceG.addAttribute('aNum', nums);
      this.instanceG.addAttribute('aRandom', randoms);
      this.instanceG.addAttribute('aColor', colors);

      this.uniforms = {
        isFog: { type: 'i', value: this.controls.props.fog },
        // isHemiLight: {type: 'i', value: this.controls.props.hemisphereLight},
        isShadowmap: { type: 'i', value: this.controls.props.shadowmap },

        uTick: { type: 'f', value: 0 },
        uTileWidth: { type: 'f', value: this.objSize },
        uDirLightPos: { type: 'v3', value: this.light.position },

        posMap: { type: 't', value: this.sim.gpuCompute.getCurrentRenderTarget(this.sim.pos).texture },
        velMap: { type: 't', value: this.sim.gpuCompute.getCurrentRenderTarget(this.sim.vel).texture },
        uSize: { type: 'f', value: this.textureSize },

        uRange: { type: 'f', value: this.range },

        uEyePosition: { type: 'v3', value: this.webgl.camera.position },
        uFogStart: { type: 'f', value: 0.5 },
        uFogEnd: { type: 'f', value: 1.0 },
        uFogColor: { type: 'v3', value: new THREE.Color(this.controls.props.bgColor) },

        shadowMap: { type: 't', value: this.light.shadow.map.texture },
        shadowMapSize: { type: 'v2', value: this.light.shadow.mapSize },
        shadowP: { type: 'm4', value: this.shadowCamera.projectionMatrix },
        shadowV: { type: 'm4', value: this.shadowCamera.matrixWorldInverse }
      };

      this.material = new THREE.ShaderMaterial({
        vertexShader: this.webgl.vertShader[0],
        fragmentShader: this.webgl.fragShader[0],
        uniforms: this.uniforms,
        side: THREE.FrontSide
      });

      console.log(this.webgl.camera.position);

      this.shadowMaterial = new THREE.ShaderMaterial({
        vertexShader: this.webgl.vertShader[0],
        fragmentShader: this.webgl.fragShader[1],
        uniforms: this.uniforms,
        side: THREE.FrontSide
      });

      this.mesh = new THREE.Mesh(this.instanceG, this.material);
      this.webgl.scene.add(this.mesh);
    }
  }, {
    key: 'setColor',
    value: function setColor() {
      var saturation_min = 80;
      var saturation_ran = 5;
      var light_min = 60;
      var light_ran = 5;

      var hue = Math.round(360 * Math.random());
      var saturation = Math.round(saturation_min + saturation_ran * Math.random());
      var light = Math.round(light_min + light_ran * Math.random());

      return 'hsl(' + hue + ',' + saturation + '%,' + light + '%)';
    }
  }, {
    key: 'setLight',
    value: function setLight() {
      this.light = new THREE.DirectionalLight(0xffffff);
      this.light.position.set(this.range * 6.0, this.range * 2.8, this.range * 2.4);
      this.light.castShadow = true;

      var width = this.range * 14.0;
      this.light.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(width / -2, width / 2, width / 2, width / -2, 1, width));

      this.shadowCamera = this.light.shadow.camera;
      this.shadowCamera.position.copy(this.light.position);
      this.shadowCamera.lookAt(this.webgl.scene.position);

      if (this.light.shadow.map === null) {
        this.light.shadow.mapSize.x = 2048;
        this.light.shadow.mapSize.y = 2048;

        var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

        this.light.shadow.map = new THREE.WebGLRenderTarget(this.light.shadow.mapSize.x, this.light.shadow.mapSize.y, pars);
      }

      // this.webgl.scene.add( new THREE.CameraHelper( this.shadowCamera ) );
      // this.initShadowMapViewers();
    }
  }, {
    key: 'initShadowMapViewers',
    value: function initShadowMapViewers() {
      this.dirLightShadowMapViewer = new THREE.ShadowMapViewer(this.light);
      this.dirLightShadowMapViewer.position.x = 10;
      this.dirLightShadowMapViewer.position.y = 10;
      this.dirLightShadowMapViewer.size.width = 256;
      this.dirLightShadowMapViewer.size.height = 256;
      this.dirLightShadowMapViewer.update(); //Required when setting position or size directly
    }
  }, {
    key: 'render',
    value: function render(time, delta) {

      this.sim.render(time, delta);

      this.uniforms.uEyePosition.value = this.webgl.camera.position;

      this.uniforms.uTick.value = time;

      this.uniforms.posMap.value = this.sim.gpuCompute.getCurrentRenderTarget(this.sim.pos).texture;
      this.uniforms.velMap.value = this.sim.gpuCompute.getCurrentRenderTarget(this.sim.vel).texture;

      this.mesh.material = this.shadowMaterial;
      this.webgl.renderer.render(this.webgl.scene, this.shadowCamera, this.light.shadow.map);

      this.mesh.material = this.material;
      this.webgl.renderer.render(this.webgl.scene, this.webgl.camera);

      if (this.dirLightShadowMapViewer) {
        this.dirLightShadowMapViewer.render(this.webgl.renderer);
      }
    }
  }]);

  return Objs;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResizeWatch = (function () {
  function ResizeWatch() {
    var _this = this;

    _classCallCheck(this, ResizeWatch);

    this.instances = [];

    this.width = this._width = document.body.clientWidth;
    this.height = this._height = window.innerHeight;
    this.aspect = this.width / this.height;

    window.onresize = (function () {
      if (_this.instances.length === 0) return;

      _this.width = document.body.clientWidth;
      _this.height = window.innerHeight;
      _this.aspect = _this.width / _this.height;

      for (var i = 0; i < _this.instances.length; i++) {
        _this.instances[i].resizeUpdate();
      }
    }).bind(this);
  }

  _createClass(ResizeWatch, [{
    key: "register",
    value: function register(instance) {
      this.instances.push(instance);
    }
  }]);

  return ResizeWatch;
})();

window.ResizeWatch = new ResizeWatch();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Simulation = (function () {
  function Simulation(webgl, size) {
    _classCallCheck(this, Simulation);

    this.webgl = webgl;
    this.renderer = this.webgl.renderer;
    this.size = size;
    this.init();
  }

  _createClass(Simulation, [{
    key: "init",
    value: function init() {
      this.gpuCompute = new GPUComputationRenderer(this.size, this.size, this.renderer);

      this.dataPos = this.gpuCompute.createTexture();
      this.dataVel = this.gpuCompute.createTexture();
      this.dataDef = this.gpuCompute.createTexture();

      var posArray = this.dataPos.image.data;
      var velArray = this.dataVel.image.data;
      var defArray = this.dataDef.image.data;

      for (var i = 0, il = posArray.length; i < il; i += 4) {

        var phi = Math.random() * 2 * Math.PI;
        var theta = Math.random() * Math.PI;
        var r = (1.2 + Math.random() * 2) * 1.2;

        defArray[i + 0] = posArray[i + 0] = r * Math.sin(theta) * Math.cos(phi);
        defArray[i + 1] = posArray[i + 1] = r * Math.sin(theta) * Math.sin(phi) * 1.4;
        defArray[i + 2] = posArray[i + 2] = r * Math.cos(theta);
        defArray[i + 3] = posArray[i + 3] = Math.random() * 0.5;

        velArray[i + 3] = Math.random() * 100; // frames life
      }

      this.def = this.gpuCompute.addVariable("defTex", this.webgl.fragShader[2], this.dataDef);
      this.vel = this.gpuCompute.addVariable("velTex", this.webgl.fragShader[3], this.dataVel);
      this.pos = this.gpuCompute.addVariable("posTex", this.webgl.fragShader[4], this.dataPos);

      this.gpuCompute.setVariableDependencies(this.def, [this.pos, this.vel, this.def]);
      this.gpuCompute.setVariableDependencies(this.vel, [this.pos, this.vel, this.def]);
      this.gpuCompute.setVariableDependencies(this.pos, [this.pos, this.vel, this.def]);

      this.velUniforms = this.vel.material.uniforms;

      this.velUniforms.timer = { value: 0.0 };
      this.velUniforms.delta = { value: 0.0 };
      this.velUniforms.speed = { value: 0.4 };
      this.velUniforms.factor = { value: 0.5 };
      this.velUniforms.evolution = { value: 0.5 };
      this.velUniforms.radius = { value: 2.0 };

      var error = this.gpuCompute.init();
      if (error !== null) {
        console.error(error);
      }
    }
  }, {
    key: "render",
    value: function render(time, delta) {
      this.velUniforms.timer.value = time;
      this.velUniforms.delta.value = delta;

      this.gpuCompute.compute();
    }
  }]);

  return Simulation;
})();
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Webgl = (function () {
  function Webgl() {
    _classCallCheck(this, Webgl);

    this.init();
  }

  _createClass(Webgl, [{
    key: "init",
    value: function init() {
      this.width = 1400;
      this.height = 1400;
      this.aspect = this.width / this.height;
      this.setProps();
      this.container = document.getElementById("wrapper");

      this.controls = new Controls(this);

      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });

      // renderer.setPixelRatio( window.devicePixelRatio );
      this.renderer.setSize(ResizeWatch.width, ResizeWatch.height);

      this.renderer.setClearColor(this.controls.props.bgColor, 1.0);
      this.container.appendChild(this.renderer.domElement);

      var ratio = Useragnt.pc ? 1.0 : 2.0;
      this.renderer.setPixelRatio(ratio);

      this.scene = new THREE.Scene();

      this.camera = new THREE.PerspectiveCamera(this.props.fov, this.props.aspect, this.props.near, this.props.far);
      var cameraZ = 1000;
      this.camera.position.set(-800, 1000, -800);
      this.camera.lookAt(this.scene.position);

      this.time = new THREE.Clock();

      var cameraControl = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      cameraControl.enableZoom = false;

      this.loading = new Loading(this);
      this.render();

      ResizeWatch.register(this);
    }
  }, {
    key: "setProps",
    value: function setProps() {
      var width = ResizeWatch.width;
      var height = ResizeWatch.height;
      var aspect = width / height;

      this.props = {
        width: width,
        height: height,
        aspect: aspect,
        fov: 45,
        left: -width / 2,
        right: width / 2,
        top: height / 2,
        bottom: -height / 2,
        near: 0.1,
        far: 1000000,
        parent: document.getElementById("wrapper")
      };
    }
  }, {
    key: "loadComp",
    value: function loadComp() {
      this.objs = new Objs(this);

      this.controls.init();
    }
  }, {
    key: "render",
    value: function render() {
      var delta = this.time.getDelta() * 5.0;
      var time = this.time.elapsedTime;

      if (this.objs) {
        this.objs.render(time, delta);
      }

      requestAnimationFrame(this.render.bind(this));
    }
  }, {
    key: "resizeUpdate",
    value: function resizeUpdate() {
      this.setProps();
      this.renderer.setSize(this.props.width, this.props.height);

      this.camera.aspect = this.props.aspect;

      this.camera.updateProjectionMatrix();

      if (ResizeWatch.aspect > this.aspect) {
        var scale = ResizeWatch.width / this.width;
      } else {
        var scale = ResizeWatch.height / this.height;
      }
    }
  }]);

  return Webgl;
})();
"use strict";

window.onload = function () {
  var webgl = new Webgl();
};